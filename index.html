<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="LAn&#39;s BLOG">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="LAn&#39;s BLOG">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>LAn's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LAn's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/04/gesture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/04/gesture/" class="post-title-link" itemprop="url">gesture</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-04 01:25:28 / 修改时间：02:10:10" itemprop="dateCreated datePublished" datetime="2020-10-04T01:25:28+08:00">2020-10-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对地图进行操作的时候我们经常会用到一些手势,于是我查了点手势相关的信息简单介绍</p>
<p>常用的 HTML5 手势可以分为两类，单点手势和两点手势。<br>单点手势有 tap（单击），double tap（双击），long tap（长按），swipe（挥），move（移动）。<br>两点手势有 pinch（缩放），rotate（旋转）。</p>
<p>简单提一下触摸的三个API touchstart，touchmove，touchend 还有一个 touchcancel是在不小心失去手机焦点时的处理机制,可以自行考虑. 在调用三个API的时候,会用到一个事件e, 在e里面会有一个数组属性叫做 touches, 里面包含了当时的所有触点(手指) 我们需要做的就是对这些已经给出的信息进行分析,并对视图进行修改;</p>
<p>移动过于简单,就是在每次touchmove事件发生时，把两个位移点之间的坐标位置相减，就可以了。<br>在手机中,浏览器经常会自带一些后退刷新的手势,而这些手势容易和自定义的移动冲突,降低用户体验,所以在h5map中,我使用的是浏览器自带的滚动条来实现移动,使用两个div和一些css样式来隐藏滚动条.</p>
<p>单击（tap）,double tap（双击），long tap（长按），从原理上来讲都差不多, 就是检测手指和屏幕触摸的时间.</p>
<p>在 touchstart 发生时进入单击检测，只有一个接触点。没有发生 touchmove 事件或者 touchmove 在一个很小的范围,我们不能保证用户精准利落的完成点下抬起的动作。</p>
<p>touchend 发生在 touchstart后的很短时间内, 单击事件从开始到结束是很快的。</p>
<p>我们需要记录时间 自然就联想到我们的Date对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">getTime() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onTouchStart(e) &#123;</span><br><span class="line">  <span class="keyword">const</span> touchEvent = &#123;</span><br><span class="line">    startX: <span class="number">0</span>,</span><br><span class="line">    startY: <span class="number">0</span>,</span><br><span class="line">    startTime: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//记录touch开始的位置</span></span><br><span class="line">    touchEvent.startX = e.touches[<span class="number">0</span>].pageX;</span><br><span class="line">    touchEvent.startY = e.touches[<span class="number">0</span>].pageY;</span><br><span class="line">    <span class="keyword">if</span>(e.touches.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//多点监测</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//记录touch开始的时间</span></span><br><span class="line">      touchEvent.startTime = <span class="keyword">this</span>.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    ...setState...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">onTouchMove(e) &#123;</span><br><span class="line">  <span class="comment">//记录手指移动的位置</span></span><br><span class="line">  ...getState...</span><br><span class="line">  touchEvent.moveX = e.touches[<span class="number">0</span>].pageX;</span><br><span class="line">  touchEvent.moveY = e.touches[<span class="number">0</span>].pageY;</span><br><span class="line">  ...setState...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onTouchEnd(e) &#123;</span><br><span class="line">  <span class="keyword">let</span> timestamp = <span class="keyword">this</span>.getTime();</span><br><span class="line">  <span class="keyword">if</span>(touchEvent.moveX !== <span class="literal">null</span> &amp;&amp; <span class="built_in">Math</span>.abs(touchEvent.moveX - touchEvent.startX) &gt; <span class="number">10</span> ||</span><br><span class="line">    touchEvent.moveY !== <span class="literal">null</span> &amp;&amp; <span class="built_in">Math</span>.abs(touchEvent.moveY - touchEvent.startY) &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//手指移动的位移要小于10像素并且手指和屏幕的接触时间要短语500毫秒</span></span><br><span class="line">    <span class="keyword">if</span>(timestamp - touchEvent.startTime &lt; <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="comment">// 执行点击(tap)事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>长按（long press）<br>长按和单击差不多,只是在屏幕上停留的时间比较久而已.<br>我们可以这样分解：在 touchstart 发生后的很长一段时间内，如果没有发生 touchmove 或者 touchend 事件，那么就触发长按手势。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">onTouchStart(e) &#123;</span><br><span class="line">  clearTimeout(<span class="keyword">this</span>.longPressTimeout);</span><br><span class="line">  <span class="keyword">if</span>(e.touches.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.longPressTimeout = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.emitEvent(<span class="string">'onLongPress'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onTouchMove(e) &#123;</span><br><span class="line">  ...</span><br><span class="line">  clearTimeout(<span class="keyword">this</span>.longPressTimeout);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onTouchEnd(e) &#123;</span><br><span class="line">  ...</span><br><span class="line">  clearTimeout(<span class="keyword">this</span>.longPressTimeout);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样将单击的事件阈值放大也可以实现这个功能,单击时,点击事件不能超过,而长按是不少于;</p>
<p>双击（double tap）</p>
<p>双击事件是一个手指的行为。所以在 touchstart 时，我们要判断此时屏幕有几个接触点。</p>
<p>双击事件本质是两次快速的单击。也即是说，两次点击的间隔时间很短,一般来说,两个单机事件的位置也相差不大。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">onTouchStart(e) &#123;</span><br><span class="line">  <span class="keyword">if</span>(e.touches.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.previousTouchPoint) &#123;</span><br><span class="line">      <span class="comment">//两次相邻的touchstart之间距离要小于10，同时时间间隔小于300ms</span></span><br><span class="line">      <span class="keyword">if</span>( <span class="built_in">Math</span>.abs(touchEvent.startX -<span class="keyword">this</span>.previousTouchPoint.startX) &lt; <span class="number">10</span>  &amp;&amp;</span><br><span class="line">          <span class="built_in">Math</span>.abs(touchEvent.startY - <span class="keyword">this</span>.previousTouchPoint.startY) &lt; <span class="number">10</span> &amp;&amp; </span><br><span class="line">          <span class="built_in">Math</span>.abs(touchEvent.startTime - <span class="keyword">this</span>.previousTouchTime) &lt; <span class="number">300</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行双击事件</span></span><br><span class="line">            <span class="keyword">this</span>.emitEvent(<span class="string">'onDoubleTap'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存上一次touchstart的时间和位置信息</span></span><br><span class="line">  ...setstate...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>缩放（pinch）</p>
<p>缩放是两个手指的行为，需要检测屏幕上是否有两个接触点。<br>缩放比例的量化，是通过两次缩放行为之间的距离的比值得到的.<br>所以缩放的核心是获取两个接触点之间的直线距离。</p>
<p>touches给出的坐标可以让我们简单的算出两点之间的距离</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">onTouchStart(e) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(e.touches.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> point1 = e.touches[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> point2 = e.touches[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.touchDistance = <span class="keyword">this</span>.getDistance(point1, point2);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在onTouchStart函数中获取并且保存 touchstart 发生时两个接触点之间的距离。</span></span><br><span class="line"></span><br><span class="line">onTouchMove(e) &#123;</span><br><span class="line">  <span class="keyword">if</span>(e.touches.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> xLen = <span class="built_in">Math</span>.abs(e.touches[<span class="number">0</span>].pageX - e.touches[<span class="number">1</span>].pageX);</span><br><span class="line">      <span class="keyword">let</span> yLen = <span class="built_in">Math</span>.abs(e.touches[<span class="number">1</span>].pageY - e.touches[<span class="number">1</span>].pageY);</span><br><span class="line">      <span class="keyword">let</span> touchDistance = <span class="keyword">this</span>.getDistance(xLen,yLen);</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.touchDistance) &#123;</span><br><span class="line">          <span class="keyword">let</span> pinchScale = touchDistance / <span class="keyword">this</span>.touchDistance</span><br><span class="line">          <span class="keyword">this</span>.emitEvent(<span class="string">'onPinch'</span>,&#123;<span class="attr">scale</span>:pinchScale - <span class="keyword">this</span>.previousPinchScale&#125;);</span><br><span class="line">          <span class="keyword">this</span>.previousPinchScale = pinchScale;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>旋转(rotate)<br>旋转手势需要检测两个比较重要的值，一是旋转的角度，二是旋转的方向（顺时针或逆时针）。</p>
<p><a href="https://blog.csdn.net/llll789789/article/details/98963341" target="_blank" rel="noopener">引用原文</a><br>首先，需要获取向量的旋转方向和角度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两个方法属于向量计算</span></span><br><span class="line"></span><br><span class="line">   getRotateDirection(vector1,vector2) &#123;</span><br><span class="line">    <span class="keyword">return</span> vector1.x * vector2.y - vector2.x * vector1.y;</span><br><span class="line">  &#125;  </span><br><span class="line">  getRotateAngle(vector1,vector2) &#123;</span><br><span class="line">    <span class="keyword">let</span> direction = <span class="keyword">this</span>.getRotateDirection(vector1,vector2);</span><br><span class="line">    direction = direction &gt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> len1 = <span class="keyword">this</span>.getDistance(vector1.x,vector1.y);</span><br><span class="line">    <span class="keyword">let</span> len2 = <span class="keyword">this</span>.getDistance(vector2.x,vector2.y);</span><br><span class="line">    <span class="keyword">let</span> mr = len1 * len2;</span><br><span class="line">    <span class="keyword">if</span>(mr === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dot = vector1.x * vector2.x + vector1.y * vector2.y;</span><br><span class="line">    <span class="keyword">let</span> r = dot / mr;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; <span class="number">1</span>) r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">-1</span>) r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.acos(r) * direction * <span class="number">180</span> / <span class="built_in">Math</span>.PI;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们在手指发生移动时，调用获取旋转方向和角度的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">onTouchStart(e) &#123;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="keyword">if</span>(e.touches.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.touchVector = &#123;</span><br><span class="line">       x: point2.pageX - touchEvent.startX,</span><br><span class="line">       y: point2.pageY - touchEvent.startY</span><br><span class="line">     &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onTouchMove(e) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.touchVector) &#123;</span><br><span class="line">        <span class="keyword">let</span> vector = &#123;</span><br><span class="line">          x: e.touches[<span class="number">1</span>].pageX - e.touches[<span class="number">0</span>].pageX,</span><br><span class="line">          y: e.touches[<span class="number">1</span>].pageY - e.touches[<span class="number">0</span>].pageY</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> angle = <span class="keyword">this</span>.getRotateAngle(vector,<span class="keyword">this</span>.touchVector);</span><br><span class="line">        <span class="comment">// 将角度(方向由正负决定)传入函数执行对应操作</span></span><br><span class="line">        <span class="keyword">this</span>.emitEvent(<span class="string">'onRotate'</span>,&#123;angle&#125;);</span><br><span class="line">        <span class="keyword">this</span>.touchVector.x = vector.x;</span><br><span class="line">        <span class="keyword">this</span>.touchVector.y = vector.y;</span><br><span class="line">      &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对手势的判断本质上就是对一个个点的判断, 有了办法获取手机上的点,通过某种计算就可以得到我们想要的结果.我在这次的h5项目中对移动的判断还添加了双指移动和三指移动,后来因为两个原因删除了,第一个是手机浏览器自带的手势功能会极大影响我写的移动逻辑,第二个就是移动的效果并不是那么的流畅,怎么考虑都是原生的滚动条占优势. 但本质的判断就是通过两个指头或者三个指头,算出一个基准点,因为算基准点的算法是一样的,所以用这个标准就可以去衡量地图的移动.</p>
<p>我就用三个指头两两距离的均值来作为缩放的基准,三个指头三角形的重心作为移动的基准点,在缩放的同时进行移动,大家也可以根据自己的想法组合数据,达到自己想要的效果.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/hotMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/02/hotMap/" class="post-title-link" itemprop="url">小地图程序带给我的痛苦</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-02 00:00:00" itemprop="dateCreated datePublished" datetime="2020-10-02T00:00:00+08:00">2020-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-04 01:25:03" itemprop="dateModified" datetime="2020-10-04T01:25:03+08:00">2020-10-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://gzsmap.ccnu.edu.cn" target="_blank" rel="noopener">h5map</a></p>
<p>一张简单的地图需要几个功能,移动地图,点击标记,放大缩小…</p>
<p>不管移动地图,先来说一说对地图的标记和点击;</p>
<p>对于不同的手机,屏幕有不同的大小,想要适配手机,就必须空余出手机参数,让浏览器填补参数,自动计算.这些都是题外话,和我想说的没有什么太大关系.这篇想讲的是图片的分区点击.</p>
<p>在接到这个项目的时候,我第一个想到的就是找一个和图片一样大的div元素,把这个div元素覆盖到这张图片上面,再在这个div中放入若干个其他的div,给里面的元素设置点击事件,点击之后就在视图层添加一个标记.这些div的布局,最简单的,第一个想到的就是绝对定位,当然使用transform: trnaslate()也是一样的.这个方法有一个优点,可以使用border-radius属性让点击区域拥有圆角,但也有一个缺点,对于精细的不规则区域来说,这个方法想要成功,就要用很多个小的div去拼接成一个大的点击区域.</p>
<p>并不是特别清楚一个真正的map应该怎么做,但是总是只用div让我觉得自己呆呆的,于是我又去搜了另一个东西 ———— 图片热区 <code>&lt;area&gt;</code>标签 还有 <code>&lt;map&gt;</code>标签, 这个标签的英文名让我觉得这个才是我需要的;</p>
<p>先简单的介绍一下这个元素</p>
<p>area 顾名思义 区域; 是用来定义点击的区域的; 他有几个属性</p>
<p><code>&lt;area shape=&quot;&quot; coords=&quot;&quot; href =&quot;&quot; alt=&quot;&quot; /&gt;</code></p>
<p>shape coords href alt, 还支持html的全局属性和事件属性;</p>
<p>shape 用来指定区域的形状 有三个值 ‘rect’, ‘circle’, ‘poly’ 矩形区域, 圆形区域和不规则区域;<br>coords 用来指定区域的位置;<br>href 指定点击之后的链接<br>alt 替代文本</p>
<p>rect 对应的 coords 是 “number1, number2, number3, number4” 分别代表矩形的一组对角坐标,前两个一个角,后两个一个角;<br>circle 对应的 coords 是 “x:number1, y: number2, radius: number3” 对应圆的中心点坐标和圆的半径;<br>poly 对应的 coords 是一连串的坐标”x1,y1,x2,y2,x3,y3…” 浏览器会将最后一个点和第一个点自动闭合.</p>
<p><code>&lt;a&gt;</code>标签也支持这两个属性</p>
<p>如果某个 area 标签中的坐标和其他区域发生了重叠，会优先采用最先出现的 area 标签。浏览器会忽略超过图像边界范围之外的坐标;</p>
<p>有了点击的区域,那需要将 图片和区域连接起来,这里就需要另一个:<code>&lt;Map&gt;</code>标签;<br>  <code>&lt;map name=&quot;&quot; id=&quot;&quot;&gt;</code><br>  主要就是这两个属性,在 <a href="https://www.w3school.com.cn/tags/tag_map.asp" target="_blank" rel="noopener">W3school</a>中写到”<code>&lt;img&gt;</code>中的 usemap 属性可引用 <code>&lt;map&gt;</code> 中的 id 或 name 属性（取决于浏览器），所以我们应同时向 <code>&lt;map&gt;</code> 添加 id 和 name 属性。”<br>所以在填写时需要将两个一并填上.</p>
<p>上面提到了 usemap 这个就是 链接图片和热区的必要属性;</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#"</span> <span class="attr">alt</span>=<span class="string">"#"</span> <span class="attr">usemap</span>=<span class="string">"#map"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"map"</span> <span class="attr">id</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"0,0,1,1"</span> <span class="attr">href</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"1,1,2,2"</span> <span class="attr">href</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"2,2,3,3"</span> <span class="attr">href</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"3,3,4,4"</span> <span class="attr">href</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个就是一个完整的例子.实际的展示可以在W3School中试验.</p>
<p>我们只要指定每个area元素的点击事件,浏览器就会根据绑定的事件进行处理. 功能已经实现,数据的处理就看个人的把握了.在标记地图点的时候一定要记得把名字起好,不然校对的时候会很麻烦.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/26/note/" class="post-title-link" itemprop="url">note</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-26 16:22:21 / 修改时间：17:58:30" itemprop="dateCreated datePublished" datetime="2020-07-26T16:22:21+08:00">2020-07-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>title: note<br>date: 2020.07.26<br>tag:  note</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/23/share3-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/23/share3-2/" class="post-title-link" itemprop="url">19级分享</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-23 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-23T00:00:00+08:00">2020-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-26 15:41:40" itemprop="dateModified" datetime="2020-07-26T15:41:40+08:00">2020-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知, 生活在js里的数组和对象是一种桀骜不驯的引用类型, 我们无法用’=’让他们好好听话, 小小的’=’无法创造新的对象, 只能创造出他们的分身, 这实在是令人沮丧.  但是记录历史我们是专业的, 有幸我们寻找到了驯服野生引用类型的珍贵资料.</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>引用类型是一种可以套娃的”数据类型”, 浅拷贝只是在第一层, 而深拷贝可以在无数层;对象利用<code>Object.keys(obj);</code>,<code>Object.getOwnPropertyNames</code>和<code>for...in</code>或者遍历等对各个键值对进行复制.<br>例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objShallowClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.hasOwnProperty(i)) &#123;</span><br><span class="line">            target[i] = source[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayShallowClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.map(<span class="function">(<span class="params">a</span>) =&gt;</span> a;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>方法一 JSON转换 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<p>（1）如果对象里有函数,函数无法被拷贝下来</p>
<p>（2）无法拷贝copyObj对象原型链上的属性和方法</p>
<p>（3）当数据的层次很深，会栈溢出</p>
<p>方法二 递归函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params"> source </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">typeof</span> sourse === <span class="string">'object'</span> &amp;&amp; sourse !== <span class="literal">null</span>)) <span class="keyword">return</span> source; </span><br><span class="line">  <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray( source ) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> source ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source.hasOwnProperty(k)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="keyword">typeof</span> source[ k ] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">            target[ k ] = deepCopy( source[ k ] )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[ k ] = source[ k ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点<br> (1) 当数据的层次很深，会栈溢出;</p>
<p>方法三 模拟栈克隆</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneLoop</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">const</span> loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            parent: root,</span><br><span class="line">            key: <span class="literal">undefined</span>,</span><br><span class="line">            data: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loopList.length) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">        <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">        <span class="keyword">const</span> key = node.key;</span><br><span class="line">        <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">        <span class="keyword">let</span> res = parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        parent: res,   <span class="comment">//对象主体</span></span><br><span class="line">                        key: k,        <span class="comment">//属性名</span></span><br><span class="line">                        data: data[k], <span class="comment">//属性值</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以这个对象为例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  describe: <span class="string">"floor1"</span>,</span><br><span class="line">  parent:&#123;</span><br><span class="line">    describe: <span class="string">"floor2"</span>,</span><br><span class="line">    parent:&#123;</span><br><span class="line">      describe: <span class="string">"floor3"</span>,</span><br><span class="line">      parent:&#123;</span><br><span class="line">        describe: <span class="string">"floor4"</span>,</span><br><span class="line">        parent:&#123;</span><br><span class="line">          child: <span class="string">"floor5"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  parent2:&#123;</span><br><span class="line">    describe: <span class="string">"floor2"</span>,</span><br><span class="line">    parent2:&#123;</span><br><span class="line">      child: <span class="string">"floor3"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次循环中res为<code>{}</code>, 遍历obj中的属性, 符合OwnProperty的对象会被记录,而普通的基本数据会被复制. 此时<code>looplist</code>的值为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">looplist = [&#123;</span><br><span class="line">  parent: &#123;</span><br><span class="line">    descibe: <span class="string">"floor1"</span></span><br><span class="line">  &#125;(<span class="number">1</span>),</span><br><span class="line">  key: <span class="string">"parent"</span>,</span><br><span class="line">  data: obj[parent]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">  parent: &#123;</span><br><span class="line">    descibe: <span class="string">"floor1"</span></span><br><span class="line">  &#125;(<span class="number">1</span>),</span><br><span class="line">  key: <span class="string">"parent2"</span>,</span><br><span class="line">  data: obj[parent2]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>最外层的对象遍历完成list中的元素, 相比利用递归算法使用真正的栈, 这个算法利用数组模拟栈, 使得栈不会轻易溢出, 增强了程序运行的稳定性.<br>第二次循环复制  <code>parent2</code>这个对象, <code>describe</code>会被推入对象, 而里面的的<code>parent2</code>对象会被放入模拟栈中, 等待执行.<br>第三次会将<code>child: floor3</code>复制…<br>由此可知, 每次执行时都会复制当层对象的基本数据, 将对象推入栈中. 逐层将对象完善.<br>在我认为, 递归算法是一次性将所有属性放到新的对象中, 不求出这个对象到底是什么不继续复制当层数据, 而这个算法是分次将属性复制, 我不在乎这个对象是什么, 只需要这里有一个对象, 等我把大体做完再追求细节, 这种思维是值得学习的. 将栈高转化成栈宽也是值得学习的.</p>
<p>数组的拷贝也是如此, 在执行的时候再加入一条数组的判断, 上面的程序会更加完整.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/23/share3-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/23/share3-1/" class="post-title-link" itemprop="url">19级分享</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-23 00:00:00 / 修改时间：22:02:35" itemprop="dateCreated datePublished" datetime="2020-07-23T00:00:00+08:00">2020-07-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事件-event"><a href="#事件-event" class="headerlink" title="事件(event)"></a>事件(event)</h2><p>事件被定义用来处理 用户 和 页面 的交互.onabort, onblur, onchange…等都是常见的<a href="https://www.w3school.com.cn/js/jsref_events.asp" target="_blank" rel="noopener">事件</a>.</p>
<p>在js中,我们可以通过对元素的事件添加函数来绑定事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params">...arg</span>) </span>&#123; statements &#125;;</span><br></pre></td></tr></table></figure>
<p>对一个DOM元素进行多次绑定时,后者将覆盖前者.<br>移除事件只需要将绑定在DOM元素的函数重新赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>).onclick = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种注册事件的方式支持一个事件绑定多个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> demo = <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>);</span><br><span class="line">demo.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  statements;</span><br><span class="line">&#125;，<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//第三个参数默认为false,事件冒泡。如果是true则是事件捕获</span></span><br><span class="line">demo.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  statements2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>事件移除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo.removeEventListener(<span class="string">'click'</span>, func);</span><br><span class="line"><span class="comment">// func 是 已经添加的有命名的函数, 匿名函数无法移除</span></span><br></pre></td></tr></table></figure>

<p>老版本事件注册, 当时ie不支持事件捕获, 所以只有两个参数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demo.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; statement &#125;);</span><br><span class="line">demo.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; statement &#125;);</span><br><span class="line"><span class="comment">//移除事件</span></span><br><span class="line">demo.detachEvent(<span class="string">'onclick'</span>, func);</span><br></pre></td></tr></table></figure>

<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>网页是一个树状结构, 当事件触发时, 网页可以从出发事件的元素开始向上传递信息, 一层层向上冒泡, 也可以由网页向下去寻找捕获触发事件的元素.<br>现在的网页结合了两种, 当事件发生时, 网页会从最大的window出发, 经由document,body…ele捕获到交互的元素, 再从这个元素开始, 原路返回, 向上冒泡.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">``` </span><br><span class="line">事件传递 window -&gt; document -&gt; body -&gt; div -&gt; p -&gt; /p -&gt; /div -&gt; /body -&gt; document -&gt; window</span><br><span class="line">事件冒泡只会在自己的window范围内执行, 如果使用 iframe 将页面进行 套娃, 外部元素的事件不会收到内部的冒泡信息;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 `event.stopPropagation();`可以阻止事件进一步传递; 既可以阻止捕获, 也可以阻止冒泡, 当一个元素上绑定了多个事件时, 同类事件会被执行. </span><br><span class="line"></span><br><span class="line">例如 div['a1','b1','c1'] -&gt; div2['a2','b2 || ','c2'] -&gt; /div2['/a1','/b1','/c1'] -&gt; /div['/a1','/b1','/c1']</span><br><span class="line">(括号内表示依次被绑定的函数 alert(x), || 表示 event.stopPropagation(); )</span><br><span class="line">那么输出是 a1,b1,c1,a2,b2,c2; 同一个元素的后续会被执行;</span><br><span class="line"></span><br><span class="line">`event.stopImmediatePropagation();` 与 `event.stopPropagation();` 类似, 但是 `event.stopImmediatePropagation();`会阻止同类事件继续执行, 即输出为 a1,b1,c1,a2,b2;</span><br><span class="line"></span><br><span class="line">在react中注册事件[参考链接](https://segmentfault.com/a/1190000017855734)</span><br><span class="line">``` jsx</span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onClick</span>=<span class="string">&#123;this.func&#125;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onClickCapture</span>=<span class="string">&#123;this.func&#125;</span></span></span><br><span class="line"><span class="tag"> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在react中的事件是合成事件, 并不是js原生的. 在这个系统中,所有事件委托给顶部的document元素, 由document统一执行触发.在合成事件中<code>event.stopPropagation();</code>并不能真正阻止事件传播.”元素被点击时，真正的元素还是按照冒泡的方式，层层将事件交给上级元素进行处理，最后事件传播到docuement，触发合成事件”<code>event.stopPropagation();</code>阻止的是合成事件中的事件流. 如果给交互的元素绑定上真正的事件, 合成事件会被终止.<br>从合成事件里的event中可以获取原生event的属性,但是这个对象对于全局来说只有一个,每次事件结束之后会被清空,因此无法用异步操作获取.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  onClick=&#123;(e)=&gt;&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        x: e.clientX,</span><br><span class="line">        y: e.clientY</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Warning: This synthetic event is reused for preformance reasons.</span></span><br></pre></td></tr></table></figure>
<p>有时我们需要混合使用原生事件与合成事件, 在生命周期中添加 <code>document.addEventListener(&#39;click&#39;, function(){});</code>, 上文提到在元素上绑定的事件会被处理成合成事件绑定在document中, 所以在触发一个时,必定触发另一个<code>event.stopPropagation();</code>无法阻止事件传播.必要时我们可以通过ref获取元素实例,通过对比 原生中<code>e.target</code>是否与合成事件中的目标相同来对控制流进行改变. 获取实例<code>React.createRef();</code></p>
<p>在nodejs中的event模块也是大同小异<br>event有且仅提供了一个events.EventEmitter对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br></pre></td></tr></table></figure>
<p>添加事件 <code>eventEmitter.addListener(&#39;eventName&#39;, listener);</code>或者<code>eventEmitter.on(&#39;eventName&#39;, listener);</code><br>移除事件 <code>removeListener(&#39;eventName&#39;, listener)</code> 移除所有,或指定复数事件 <code>removeAllListeners([event])</code><br>监听事件<code>emit(event, ...argu);</code><br>设置事件最大数量 <code>life.setMaxListeners(eventCount);</code><br>…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/27/java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/java/" class="post-title-link" itemprop="url">JAVA NOTE</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-27 00:00:00 / 修改时间：23:22:14" itemprop="dateCreated datePublished" datetime="2020-05-27T00:00:00+08:00">2020-05-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>声明变量<br>整数类(byte、short、int、long)、文本类(char)、浮点类(double、float)和逻辑类(boolean)。<br>int a = 123;<br>static a = 123;</li>
</ol>
<p>对象运算符 instanceof 判断是否属于某类或其子类实例</p>
<p>int a[]={};<br>pencil b[]={};<br>a = new int[10];<br>b = new pencil[20];<br>访问说明符 class 类名 extends 超类名 implements 接口名<br>访问说明符有public、private和protected三种</p>
<p>Hashtable类<br>Enumeration接口<br>StringBuffer类<br>StringTokenizer类</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/01/share-2.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/share-2.1/" class="post-title-link" itemprop="url">19级分享</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-01T00:00:00+08:00">2020-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-24 16:30:30" itemprop="dateModified" datetime="2020-04-24T16:30:30+08:00">2020-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="将-react-配置到-github-pages-上"><a href="#将-react-配置到-github-pages-上" class="headerlink" title="将 react 配置到 github pages 上"></a>将 react 配置到 github pages 上</h3><p>没钱买服务器，又想要和别人分享自己的文件，第一个想到的就是github-pages。但是位子又被hexo博客占用了，一开始想的是不停的往这个站点下面提交不同的文件，但是感觉太麻烦了，就发现了这个。</p>
<p>gh-pages是github-pages的分支页面，将文件上传到分支之后就可以了</p>
<p>推送的文件必须是打包后的静态文件，所以在提交之前先执行打包 <code>npm run build</code></p>
<ol>
<li><p>配置 package.json 文件</p>
<p> 设置homepage保证css和js的路径不会出错</p>
<p> homepage 地址为 github page 分支地址一般为”<a href="https://user-name.github.io/project-name&quot;" target="_blank" rel="noopener">https://user-name.github.io/project-name&quot;</a></p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"share"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"https://shi-zhong.github.io/share"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目目录下运行终端</p>
<ol>
<li>创建分支 gh-pages<br><code>git checkout --orphan gh-pages</code></li>
<li>提交本地<br><code>git add ..</code> and <code>git commit -m ..</code></li>
<li>提交到分支<br><code>git push origin gh-pages</code></li>
</ol>
<hr>
<p>或者安装 gh-pages 简化提交过程</p>
<ol>
<li>安装 <font color="blue">gh-pages</font></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gh-pages --save-dev</span><br></pre></td></tr></table></figure>

<p>  gh-pages官网<a href="https://www.npmjs.com/package/gh-pages" target="_blank" rel="noopener">https://www.npmjs.com/package/gh-pages</a></p>
<ol start="2">
<li>配置脚本 “predeploy”: 打包文件; “deploy”: 上传文件至github的分支</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "react-scripts start",</span><br><span class="line">  "build": "react-scripts build",</span><br><span class="line">  "test": "react-scripts test",</span><br><span class="line">  "eject": "react-scripts eject",</span><br><span class="line">  "predeploy": "npm run build",</span><br><span class="line">  "deploy": "gh-pages -d build"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>将文件上传至github, 执行<code>npm run deploy</code><br>终端会将文件打包并将编好的文件</p>
</li>
<li><p>访问 设置的网址</p>
</li>
</ol>
<h3 id="下拉刷新的实现"><a href="#下拉刷新的实现" class="headerlink" title="下拉刷新的实现"></a>下拉刷新的实现</h3><p>下拉刷新的实现有以下几个要求:</p>
<ol>
<li>触顶下拉</li>
<li>松手回弹</li>
<li>阈值刷新</li>
</ol>
<p>使画面移动的方法有很多，通过<font color="blue">定位</font>来改变，通过<font color="blue">translate</font>来改变，还可一通过设置滚动条的<font color="blue">scrollTop</font>实现。</p>
<p>看到的刷新大致有两种,一种是内容框跟着下移,动画框出现,另一种是内容框不动,动画框下降</p>
<h4 id="内容框不动"><a href="#内容框不动" class="headerlink" title="内容框不动"></a>内容框不动</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模拟屏幕--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--动画框--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'anima'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--正文框--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'container'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先要让动画框隐藏,只是设置初始translateY(-100%)的话,anima这个框仍然会占位子,所以要设置负的margin-top,让anima框隐藏</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.anima</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在窗体的滚动条到顶之后,才能够判定下拉与否,所以在滑动时需要检测内容框的<font color="blue">scrollTop</font>是否为零, 只有在<font color="blue">scrollTop</font>等于零时下拉才能触发下拉刷新的准备动画.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scrollTop存在target中</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">scrollTop</span>: e.target.scrollTop&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时需要一个值来存储滑动的距离,每次触发滑动事件时会获得触摸点的坐标,由此可以判断手的移动.输出<font color="green">console</font>.<font color="goldenRod">log</font>( <font color="dodgerBlue">e.touches[0]</font> ) 就可以看见关于触摸点的信息<br><font color="blue">clientX(Y)</font> 关于body可视部分的坐标<br><font color="blue">pageX(Y)</font> 包含不可视部分坐标,包含了滚动条隐藏掉的部分<br><font color="blue">screenX(Y)</font> 屏幕的坐标</p>
</li>
</ol>
<p>在滚动条没到顶之前滑动距离对我们没有意义,到顶之后滑动的距离会被反映在动画中,用<font color="blue">preSrcoll</font>记录上一次的触摸点,用<font color="blue">transDis</font>来记录现在下拉部分的位置.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; preTouch &#125; = <span class="keyword">this</span>.state</span><br><span class="line"><span class="keyword">const</span> delta = e.touches[<span class="number">0</span>].clientY - preTouch</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  preTouch: e.touches[<span class="number">0</span>].clientY,</span><br><span class="line">  transDis: transDis + delta</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>判断是否刷新只需要在触摸结束时判断<font color="blue">transDis</font>的大小即可.<br>为代码添加事件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; transDis &#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="comment">// 对数据处理生成样式</span></span><br><span class="line">  <span class="keyword">const</span> Style = &#123;</span><br><span class="line">    transform: <span class="string">'translateY('</span>+ fun(transDis) +<span class="string">')'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">'anima'</span></span><br><span class="line">        style=&#123;Style&#125;</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div</span></span><br><span class="line"><span class="regexp">        className='container'</span></span><br><span class="line"><span class="regexp">        onTouchStart=&#123;this.handleTouchStart.bind(this)&#125;</span></span><br><span class="line"><span class="regexp">        onTouchMove=&#123;this.handleTouchMove.bind(this)&#125;</span></span><br><span class="line"><span class="regexp">        onTouchEnd=&#123;this.handleTouchEnd.bind(this)&#125;</span></span><br><span class="line"><span class="regexp">      &gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>各事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">handleTouchStart (e) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; </span><br><span class="line">    preTouch: e.touches[<span class="number">0</span>].clientY,</span><br><span class="line">    scrollTop: e.target.scrollTop</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleTouchMove (e) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; scrollTop, transDis, preTouch &#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">const</span> deltaY = e.touches[<span class="number">0</span>].clientY - preTouch</span><br><span class="line">  <span class="keyword">if</span> ( scrollTop === <span class="number">0</span> &amp;&amp; transDis &lt;= <span class="number">40</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transDis +deltaY*<span class="number">0.4</span> &lt; <span class="number">40</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">transDis</span>: transDis + deltaY*<span class="number">0.4</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">transDis</span>: <span class="number">40</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">preTouch</span>: e.touches[<span class="number">0</span>].clientY &#125;)</span><br><span class="line">    <span class="comment">// 防止下拉一部分后往回滑动时页面跟着往上走</span></span><br><span class="line">    <span class="comment">// 需要阻止滑动的默认行为</span></span><br><span class="line">    e.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">scrollTop</span>: e.target.scrollTop &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleTouchEnd () &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; transDis &#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">if</span> ( transDis === <span class="number">40</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      <span class="comment">// 下拉刷新动画以及请求</span></span><br><span class="line">      animate: <span class="literal">true</span></span><br><span class="line">    &#125;,setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        transDis: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 下拉动画结束</span></span><br><span class="line">        animate: <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,<span class="number">1000</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//复位</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">transDis</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种的下拉在滑动的判定上也是同一个道理,只需要将移动的动画应用到内容框即可.top和scrollTop也是同理,不同的选择要处于流畅度和性能,transform似乎流畅度最好的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/links/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/14/links/" class="post-title-link" itemprop="url">网页制作中的一些知识点(链接)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-14 20:02:44" itemprop="dateCreated datePublished" datetime="2020-04-14T20:02:44+08:00">2020-04-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>vertical-align <a href="http://www.cnblogs.com/starof/articles/4512284.html" target="_blank" rel="noopener">点击传送</a></li>
<li>桌面美化 <a href="https://blog.csdn.net/lfs666666/article/details/87200054" target="_blank" rel="noopener">links</a></li>
<li>桌面主题 <code>sudo apt-get install gnome-tweak-tool</code><br><a href="https://blog.csdn.net/lishanleilixin/article/details/80453565" target="_blank" rel="noopener">gnome-tweak-tool</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/react-about/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/react-about/" class="post-title-link" itemprop="url">react 有关</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 23:29:08" itemprop="dateCreated datePublished" datetime="2020-03-20T23:29:08+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-21 00:00:27" itemprop="dateModified" datetime="2020-03-21T00:00:27+08:00">2020-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="将-react-配置到-github-pages-上"><a href="#将-react-配置到-github-pages-上" class="headerlink" title="将 react 配置到 github pages 上"></a>将 react 配置到 github pages 上</h4><ol>
<li><p>配置 package.json 文件</p>
<p> homepage 为 clone 地址 前缀改为 github page 地址</p>
<p> 地址: <code>https://github.com/shi-zhong/birth.git</code></p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"birth"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"https://shi-zhong.github.io/birth"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<p>配置脚本 “predeploy”: 打包文件; “deploy”: 上传文件至github的分支</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "react-scripts start",</span><br><span class="line">  "build": "react-scripts build",</span><br><span class="line">  "test": "react-scripts test",</span><br><span class="line">  "eject": "react-scripts eject",</span><br><span class="line">  "predeploy": "npm run build",</span><br><span class="line">  "deploy": "gh-pages -d build"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 gh-pages</li>
</ol>
<p><code>npm install gh-pages --save-dev</code></p>
<p>  gh-pages官网<a href="https://www.npmjs.com/package/gh-pages" target="_blank" rel="noopener">https://www.npmjs.com/package/gh-pages</a></p>
<ol start="3">
<li><p>将文件上传至github, 执行<code>npm run deploy</code></p>
</li>
<li><p>访问 设置的网址</p>
</li>
</ol>
<h4 id="安装-react-router"><a href="#安装-react-router" class="headerlink" title="安装 react-router"></a>安装 react-router</h4><ol>
<li><p>执行代码 <code>npm install react-router-dom</code></p>
</li>
<li><p>报错 <code>Unexpected end of JSON input while parsing near</code> 执行 <code>npm cache clean --force</code></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/c-yuyan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LAn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAn's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/18/c-yuyan/" class="post-title-link" itemprop="url">C语言笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-18 21:22:10" itemprop="dateCreated datePublished" datetime="2020-03-18T21:22:10+08:00">2020-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-19 01:03:13" itemprop="dateModified" datetime="2020-03-19T01:03:13+08:00">2020-03-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="第一章-C语言程序设计预备知识"><a href="#第一章-C语言程序设计预备知识" class="headerlink" title="第一章 C语言程序设计预备知识"></a>第一章 C语言程序设计预备知识</h4><ol>
<li>硬件系统基本组成及工作原理<br>（1）运算器  -|<br>（2）控制器  -|-CPU<br>（3）存储器<br>（4）输入设备<br>（5）输出设备</li>
<li>进制转换<br>小数转换：小数部分乘以2，记录整数部分，直至小数为零或者达到精度</li>
<li>数据在计算机内部的存储<br>（1）原码 首位为符号位<br>（2）反码 首位为符号位，正数反码与原码相同，负数除首位其余按位求反<br>（3）补码 正数同原码，负数除符号位，按位求反，末位加1<br>（4）补码的计算 带符号位进行加法计算，符号位进位时，将进位的部分舍去<br>（5）ASCII 8位</li>
<li>位运算(NOT、AND、OR、XOR)</li>
</ol>
<h4 id="第二章-C元语言程序设计基础"><a href="#第二章-C元语言程序设计基础" class="headerlink" title="第二章 C元语言程序设计基础"></a>第二章 C元语言程序设计基础</h4><ol>
<li>程序语言发展<br>（1）机器语言 机器唯一识别的语言 0与1构成<br>（2）汇编语言 简单的英文字母代替特定二进制串，汇编程序用于将单词翻译成二进制串，依赖于机器硬件<br>（3）高级语言</li>
<li>C语言发展/..</li>
</ol>
<h4 id="第三章-基本数据类型、运算符与表达式"><a href="#第三章-基本数据类型、运算符与表达式" class="headerlink" title="第三章 基本数据类型、运算符与表达式"></a>第三章 基本数据类型、运算符与表达式</h4><ol>
<li>常用数据类型<br>基本数据类型（整形、字符型、实体型）、构造数据类型、指针类型、空类型</li>
<li>常量、变量和标识符<br>（1）最长有效32位，至少8位，超长部分舍去<br>（2）大小写敏感</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LAn</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LAn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
